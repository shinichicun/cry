import gmpy2
from Crypto.Util.number import *
from gmpy2 import *
n = 20289788565671012003324307131062103060859990244423187333725116068731043744218295859587498278382150779775620675092152011336913225797849717782573829179765649320271927359983554162082141908877255319715400550981462988869084618816967398571437725114356308935833701495015311197958172878812521403732038749414005661189594761246154666465178024563227666440066723650451362032162000998737626370987794816660694178305939474922064726534186386488052827919792122844587807300048430756990391177266977583227470089929347969731703368720788359127837289988944365786283419724178187242169399457608505627145016468888402441344333481249304670223
e = 11079917583
c = 13354219204055754230025847310134936965811370208880054443449019813095522768684299807719787421318648141224402269593016895821181312342830493800652737679627324687428327297369122017160142465940412477792023917546122283870042482432790385644640286392037986185997262289003477817675380787176650410819568815448960281666117602590863047680652856789877783422272330706693947399620261349458556870056095723068536573904350085124198592111773470010262148170379730937529246069218004969402885134027857991552224816835834207152308645148250837667184968030600819179396545349582556181916861808402629154688779221034610013350165801919342549766
#print(e.bit_length())

# 确认r和s的位数
"""
for m in range(10):
    print(m**2-m+2)
    # 34/2=17
    # 14 m=4
"""

# factor(e) = 3*7*7*19*691*5741
# 因为是17位，所以就只可能是下面的情况
r,s = 5741*3*7, 691*19*7
ab = int(gmpy2.iroot(n,4)[0])
# a、b都比r和s大很多，于是就有n≈(a*b)^4, ab=iroot(n,4)[0]
"""
var('a b')
f1 = a*b == ab
f2 = n == (ab**4)+a**4*s+b**4*r+r*s
print(solve([f1,f2],[a,b]))
"""
a = 47783641287938625512681830427927501009821495321018170621907812035456872958654
b = 44416071018427916652440592614276227563515579156219730344722242565477265479486
p=a**4+r
q=b**4+s
#print(gcd(e//3, p-1))
d = inverse(e//3, p-1)
m_72 = pow(c,d,n)
e = 3
P.<a>=PolynomialRing(Zmod(p),implementation='NTL')
f = a^e - m_72
mps=f.monic().roots()
for i in mps:
    flag=long_to_bytes(int(i[0]))
    if b"flag" in flag or b"DASCTF" in flag:
        print(flag)
